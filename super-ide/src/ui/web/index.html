<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Super IDE - AI-Powered Development Environment</title>
    
    <!-- Monaco Editor -->
    <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.44.0/min/vs/loader.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Fira Code', 'Monaco', 'Consolas', monospace;
            background-color: #1E1E1E;
            color: #D4D4D4;
            overflow: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 250px 1fr;
            grid-template-rows: 50px 1fr 200px;
            grid-template-areas: 
                "header header"
                "sidebar main"
                "status status";
            height: 100vh;
        }

        /* Header */
        .header {
            grid-area: header;
            background-color: #2D2D30;
            border-bottom: 1px solid #3E3E42;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .logo {
            font-size: 18px;
            font-weight: bold;
            color: #007ACC;
        }

        .project-title {
            color: #CCCCCC;
            font-size: 14px;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .header-btn {
            background: none;
            border: none;
            color: #CCCCCC;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .header-btn:hover {
            background-color: #37373D;
        }

        .ai-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            color: #4EC9B0;
            font-size: 12px;
        }

        .ai-status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #4EC9B0;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* Sidebar */
        .sidebar {
            grid-area: sidebar;
            background-color: #252526;
            border-right: 1px solid #3E3E42;
            display: flex;
            flex-direction: column;
        }

        .sidebar-header {
            padding: 16px;
            border-bottom: 1px solid #3E3E42;
        }

        .sidebar-title {
            font-size: 14px;
            font-weight: bold;
            color: #CCCCCC;
            margin-bottom: 8px;
        }

        .file-tree {
            flex: 1;
            overflow-y: auto;
            padding: 8px 0;
        }

        .file-item {
            padding: 6px 16px;
            cursor: pointer;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background-color 0.2s;
        }

        .file-item:hover {
            background-color: #2A2D2E;
        }

        .file-item.active {
            background-color: #094771;
            color: #FFFFFF;
        }

        .file-icon {
            width: 16px;
            height: 16px;
            color: #CCCCCC;
        }

        .file-folder {
            color: #D19A66;
        }

        .file-code {
            color: #CE9178;
        }

        /* Main Content */
        .main-content {
            grid-area: main;
            display: flex;
            flex-direction: column;
        }

        .tab-bar {
            background-color: #2D2D30;
            border-bottom: 1px solid #3E3E42;
            display: flex;
            align-items: center;
            overflow-x: auto;
        }

        .tab {
            padding: 12px 16px;
            border-right: 1px solid #3E3E42;
            cursor: pointer;
            white-space: nowrap;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
            position: relative;
        }

        .tab.active {
            background-color: #1E1E1E;
            color: #FFFFFF;
        }

        .tab:hover {
            background-color: #37373D;
        }

        .tab-modified::after {
            content: '‚óè';
            color: #F48771;
            font-size: 8px;
            margin-left: 4px;
        }

        .close-btn {
            background: none;
            border: none;
            color: #CCCCCC;
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 2px;
        }

        .close-btn:hover {
            background-color: #E81123;
            color: white;
        }

        .editor-container {
            flex: 1;
            position: relative;
        }

        .editor {
            width: 100%;
            height: 100%;
            background-color: #1E1E1E;
            color: #D4D4D4;
            border: none;
            outline: none;
        }

        .monaco-editor {
            width: 100% !important;
            height: 100% !important;
        }

        .ai-assistant {
            background-color: #252526;
            border: 1px solid #3E3E42;
            margin: 8px;
            border-radius: 4px;
            padding: 12px;
            font-size: 13px;
        }

        .ai-suggestion {
            background-color: #264F78;
            border-left: 3px solid #007ACC;
            padding: 8px;
            margin: 8px 0;
            border-radius: 0 4px 4px 0;
        }

        .ai-suggestion-accept {
            background-color: #0E4429;
            border-left: 3px solid #28A745;
        }

        .ai-suggestion-reject {
            background-color: #5F1D2B;
            border-left: 3px solid #DC3545;
        }

        /* Status Bar */
        .status-bar {
            grid-area: status;
            background-color: #007ACC;
            color: white;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
            font-size: 12px;
        }

        .status-left, .status-right {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        /* Syntax Highlighting */
        .keyword { color: #569CD6; }
        .string { color: #CE9178; }
        .number { color: #B5CEA8; }
        .comment { color: #6A9955; }
        .operator { color: #D4D4D4; }

        /* Buttons */
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background-color 0.2s;
        }

        .btn-primary {
            background-color: #007ACC;
            color: white;
        }

        .btn-primary:hover {
            background-color: #1177BB;
        }

        .btn-secondary {
            background-color: #37373D;
            color: #CCCCCC;
        }

        .btn-secondary:hover {
            background-color: #404040;
        }

        /* Loading Spinner */
        .loading {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #3E3E42;
            border-radius: 50%;
            border-top-color: #007ACC;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Tooltip */
        .tooltip {
            position: absolute;
            background-color: #2D2D30;
            color: #CCCCCC;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            border: 1px solid #3E3E42;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: 50px auto 1fr 150px;
                grid-template-areas: 
                    "header"
                    "sidebar"
                    "main"
                    "status";
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header class="header">
            <div class="header-left">
                <div class="logo">üöÄ Super IDE</div>
                <div class="project-title" id="current-project">Loading...</div>
            </div>
            <div class="header-right">
                <div class="ai-indicator">
                    <div class="ai-status-dot" id="ai-status"></div>
                    <span>AI Ready</span>
                </div>
                <button class="header-btn" onclick="openFile()">üìÅ Open File</button>
                <button class="header-btn" onclick="saveFile()">üíæ Save</button>
                <button class="header-btn" onclick="toggleAI()">ü§ñ AI</button>
                <button class="header-btn" onclick="runCode()">‚ñ∂Ô∏è Run</button>
            </div>
        </header>

        <!-- Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <div class="sidebar-title">Explorer</div>
                <button class="btn btn-secondary" onclick="refreshFiles()">üîÑ Refresh</button>
            </div>
            <div class="file-tree" id="file-tree">
                <div class="file-item">
                    <svg class="file-icon file-folder" viewBox="0 0 16 16">
                        <path fill="currentColor" d="M1 3.5A1.5 1.5 0 0 1 2.5 2h5.5a1.5 1.5 0 0 1 1.5 1.5V4h8v-.5a1.5 1.5 0 0 1 1.5-1.5h5.5A1.5 1.5 0 0 1 16 4.5V14a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V3.5z"/>
                    </svg>
                    <span>src/</span>
                </div>
                <div class="file-item" onclick="openFile('main.rs')">
                    <svg class="file-icon" viewBox="0 0 16 16">
                        <path fill="currentColor" d="M9.405 1.05c-.413-1.4-2.397-1.16-2.74 0l-.07.01a.007.007 0 0 0 0 .07L7.341 6H2.47l-.01 1.47a.007.007 0 0 0 0 .07L3.65 9H1.93a.008.008 0 0 0-.007.01l-.001.001a.007.007 0 0 0 0 .07l.001.001L2.47 11h2.47l.01 1.47a.007.007 0 0 0 0 .07l.001.001a.007.007 0 0 0 0 .07L4.59 13H7.34l-.01-1.47a.007.007 0 0 0 0-.07l-.001-.001a.007.007 0 0 0 0-.07L7.34 9H5.59l-.01-1.47a.007.007 0 0 0 0-.07l-.001-.001z"/>
                    </svg>
                    <span>main.rs</span>
                </div>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Tab Bar -->
            <div class="tab-bar" id="tab-bar">
                <div class="tab active" data-file="main.rs">
                    <span>main.rs</span>
                    <button class="close-btn" onclick="closeTab('main.rs')">√ó</button>
                </div>
                <button class="btn btn-secondary" onclick="addNewTab()">+ New Tab</button>
            </div>

            <!-- Editor -->
            <div class="editor-container">
                <div class="editor" id="editor"></div>
            </div>

            <!-- AI Assistant Panel -->
            <div class="ai-assistant" id="ai-assistant" style="display: none;">
                <h3>ü§ñ AI Assistant</h3>
                <div id="ai-suggestions">
                    <div class="ai-suggestion">
                        <strong>Code Analysis:</strong> Your function has a complexity score of 2. Consider extracting some logic into helper functions for better maintainability.
                        <br><button class="btn btn-primary" onclick="acceptSuggestion()">Accept</button>
                        <button class="btn btn-secondary" onclick="rejectSuggestion()">Dismiss</button>
                    </div>
                    <div class="ai-suggestion ai-suggestion-accept">
                        <strong>Bug Prediction:</strong> Potential null pointer exception on line 15. Consider adding a null check.
                        <br><button class="btn btn-primary" onclick="acceptSuggestion()">Fix</button>
                        <button class="btn btn-secondary" onclick="rejectSuggestion()">Ignore</button>
                    </div>
                </div>
            </div>
        </main>

        <!-- Status Bar -->
        <footer class="status-bar">
            <div class="status-left">
                <div class="status-item">
                    <span>Line 1, Col 1</span>
                </div>
                <div class="status-item">
                    <span>Rust</span>
                </div>
                <div class="status-item">
                    <span>UTF-8</span>
                </div>
                <div class="status-item">
                    <div class="loading"></div>
                    <span>AI Analyzing...</span>
                </div>
            </div>
            <div class="status-right">
                <div class="status-item">
                    <span>‚ö° Performance: 98%</span>
                </div>
                <div class="status-item">
                    <span>üìÅ 3 files</span>
                </div>
                <div class="status-item">
                    <span>üîÑ Last save: 2s ago</span>
                </div>
            </div>
        </footer>
    </div>

    <script>
        // WebSocket connection for real-time features
        let ws = null;
        let aiEnabled = true;
        let currentFile = 'main.rs';
        
        // Initialize the IDE
        function initIDE() {
            connectWebSocket();
            loadFiles();
            setupEditor();
            updateStatus();
        }
        
        // Connect to WebSocket for real-time features
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;
            
            ws = new WebSocket(wsUrl);
            
            ws.onopen = function() {
                console.log('üîó Connected to Super IDE WebSocket');
                updateAIStatus(true);
            };
            
            ws.onmessage = function(event) {
                const message = JSON.parse(event.data);
                handleWebSocketMessage(message);
            };
            
            ws.onclose = function() {
                console.log('üîå Disconnected from WebSocket');
                updateAIStatus(false);
                // Attempt to reconnect after 3 seconds
                setTimeout(connectWebSocket, 3000);
            };
        }
        
        // Handle WebSocket messages
        function handleWebSocketMessage(message) {
            switch(message.type) {
                case 'ai_suggestion':
                    showAISuggestion(message.suggestion, message.confidence);
                    break;
                case 'completion':
                    handleCompletion(message.completions);
                    break;
                case 'code_analysis':
                    updateCodeAnalysis(message.analysis);
                    break;
                case 'bug_prediction':
                    updateBugPredictions(message.predictions);
                    break;
                case 'ai_completion':
                    // Handle AI completion for Monaco Editor
                    if (window.editor && message.completions) {
                        handleAICompletion(message.completions);
                    }
                    break;
                case 'file_loaded':
                    // Handle file loaded response
                    if (window.editor && message.content) {
                        const model = monaco.editor.createModel(message.content, getLanguageFromFilename(message.filename));
                        window.editor.setModel(model);
                        updateTabBar(message.filename);
                        updateEditorLanguage(message.filename);
                        updateStatusBar(`Loaded ${message.filename}`);
                    }
                    break;
                case 'file_list':
                    // Handle file list response
                    renderFileTree(message.files);
                    break;
                case 'git_status':
                    // Handle Git status response
                    renderGitStatus(message);
                    break;
                case 'git_branch_changed':
                    // Handle branch change
                    updateStatusBar(`Switched to branch: ${message.branch}`);
                    loadFiles(); // Refresh file list
                    break;
                case 'file_saved':
                    // Handle file saved confirmation
                    updateStatusBar(`Saved ${message.filename}`);
                    removeTabModifiedIndicator();
                    break;
                case 'error':
                    // Handle error messages
                    updateStatusBar(`Error: ${message.message}`);
                    console.error('Server error:', message.message);
                    break;
            }
        }

        // Handle AI completion in Monaco Editor
        function handleAICompletion(completions) {
            if (window.editor && completions.length > 0) {
                const position = window.editor.getPosition();
                const range = new monaco.Range(position.lineNumber, position.column, position.lineNumber, position.column);
                
                const suggestions = completions.map(completion => ({
                    label: completion.text,
                    kind: monaco.languages.CompletionItemKind.Function,
                    insertText: completion.text,
                    detail: `AI Suggestion (${Math.round(completion.confidence * 100)}% confidence)`,
                    sortText: 'Z', // Sort AI suggestions last
                }));

                // Show suggestions in Monaco Editor
                window.editor.trigger('keyboard', 'editor.action.triggerSuggest', { 
                    suggestions: suggestions 
                });
            }
        }
        
        // Load file list
        async function loadFiles() {
            try {
                // Request file list via WebSocket
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'load_files' }));
                }
                
                // Fallback to HTTP API
                const response = await fetch('/api/files');
                const files = await response.json();
                renderFileTree(files);
                
                // Also load Git status if available
                loadGitStatus();
            } catch (error) {
                console.error('Failed to load files:', error);
                // Show error in file tree
                const fileTree = document.getElementById('file-tree');
                fileTree.innerHTML = '<div class="file-item" style="color: #F48771;">Failed to load files</div>';
            }
        }

        // Load Git status
        async function loadGitStatus() {
            try {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'git_status' }));
                }
                
                const response = await fetch('/api/git/status');
                const gitInfo = await response.json();
                renderGitStatus(gitInfo);
            } catch (error) {
                console.log('Git not available or not a repository');
            }
        }

        // Render Git status
        function renderGitStatus(gitInfo) {
            if (gitInfo && gitInfo.isRepository) {
                // Update status bar with Git info
                const statusRight = document.querySelector('.status-right');
                const gitStatusItem = document.createElement('div');
                gitStatusItem.className = 'status-item';
                gitStatusItem.innerHTML = `
                    <span>üìã ${gitInfo.currentBranch}</span>
                    ${gitInfo.aheadCount > 0 ? `<span>‚Üë${gitInfo.aheadCount}</span>` : ''}
                    ${gitInfo.behindCount > 0 ? `<span>‚Üì${gitInfo.behindCount}</span>` : ''}
                `;
                
                // Add Git status to status bar
                const existingGitItem = statusRight.querySelector('[data-git-status]');
                if (existingGitItem) {
                    existingGitItem.remove();
                }
                gitStatusItem.setAttribute('data-git-status', 'true');
                statusRight.insertBefore(gitStatusItem, statusRight.firstChild);
            }
        }
        
        // Render file tree
        function renderFileTree(files) {
            const fileTree = document.getElementById('file-tree');
            fileTree.innerHTML = '';
            
            // Add refresh button
            const refreshButton = document.createElement('div');
            refreshButton.className = 'file-item';
            refreshButton.innerHTML = `
                <svg class="file-icon" viewBox="0 0 16 16">
                    <path fill="currentColor" d="M8 3a5 5 0 0 0-4.546 2.916A5.986 5.986 0 0 0 8 1v2zm0 14V9.236a6.01 6.01 0 0 1 3.43-2.414A5.99 5.99 0 0 1 13 8a6.02 6.02 0 0 1-5 2.764V3z"/>
                </svg>
                <span>üîÑ Refresh</span>
            `;
            refreshButton.onclick = loadFiles;
            fileTree.appendChild(refreshButton);
            
            // Add file items
            files.forEach(file => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                fileItem.onclick = () => {
                    if (file.is_directory) {
                        // Handle directory navigation
                        loadDirectory(file.path);
                    } else {
                        openFile(file.path);
                    }
                };
                
                // Add Git status indicators
                let gitIndicator = '';
                if (file.git_status) {
                    switch(file.git_status.status) {
                        case 'M':
                            gitIndicator = 'üî¥'; // Modified
                            break;
                        case 'A':
                            gitIndicator = 'üü¢'; // Added
                            break;
                        case 'D':
                            gitIndicator = 'üü†'; // Deleted
                            break;
                        case '?':
                            gitIndicator = '‚ùì'; // Untracked
                            break;
                        default:
                            gitIndicator = '';
                    }
                }
                
                const icon = file.is_directory ? 'üìÅ' : getFileIcon(file.name);
                const statusClass = file.git_status ? ` git-${file.git_status.status}` : '';
                
                fileItem.innerHTML = `
                    <span class="file-icon ${file.is_directory ? 'file-folder' : 'file-code'}${statusClass}">${icon}</span>
                    <span>${gitIndicator} ${file.name}</span>
                    ${file.size ? `<span class="file-size">${formatFileSize(file.size)}</span>` : ''}
                `;
                
                fileTree.appendChild(fileItem);
            });
        }

        // Get file icon based on extension
        function getFileIcon(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            const iconMap = {
                'rs': 'ü¶Ä', // Rust
                'py': 'üêç', // Python
                'js': 'üü®', // JavaScript
                'ts': 'üî∑', // TypeScript
                'java': '‚òï', // Java
                'cpp': '‚öôÔ∏è', // C++
                'c': '‚ö°', // C
                'go': 'üêπ', // Go
                'php': 'üêò', // PHP
                'rb': 'üíé', // Ruby
                'swift': 'üçé', // Swift
                'kt': 'üÖ∫', // Kotlin
                'scala': 'üÖ¢', // Scala
                'sh': 'üíª', // Shell
                'html': 'üåê', // HTML
                'css': 'üé®', // CSS
                'json': 'üìã', // JSON
                'xml': 'üìÑ', // XML
                'yaml': 'üìã', // YAML
                'md': 'üìñ', // Markdown
                'txt': 'üìù', // Text
                'gitignore': 'üö´' // Git ignore
            };
            return iconMap[ext] || 'üìÑ';
        }

        // Format file size
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }

        // Load directory contents
        async function loadDirectory(dirPath) {
            try {
                const response = await fetch(`/api/files/list?path=${encodeURIComponent(dirPath)}`);
                const files = await response.json();
                renderFileTree(files);
            } catch (error) {
                console.error('Failed to load directory:', error);
            }
        }
        
        // Setup Monaco Editor
        function setupEditor() {
            // Monaco Editor configuration
            require.config({ 
                paths: { 
                    'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.44.0/min/vs' 
                } 
            });

            require(['vs/editor/editor.main'], function() {
                const initialCode = `// Welcome to Super IDE - AI-Powered Development Environment
// This intelligent IDE provides:

fn main() {
    println!("üöÄ Super IDE Features:");
    
    // üß† AI-Powered Features
    println!("   ‚Ä¢ Smart code completion and suggestions");
    println!("   ‚Ä¢ Bug prediction and code smell detection");
    println!("   ‚Ä¢ Auto-documentation generation");
    println!("   ‚Ä¢ Unit test generation");
    println!("   ‚Ä¢ Code translation between languages");
    
    // üîç Advanced Error & Debugging
    println!("   ‚Ä¢ Visual debugger with breakpoints");
    println!("   ‚Ä¢ Stack trace analysis with AI explanations");
    println!("   ‚Ä¢ Performance profiling");
    println!("   ‚Ä¢ Dependency vulnerability scanning");
    
    // üí¨ AI Assistant
    println!("   ‚Ä¢ Context-aware code suggestions");
    println!("   ‚Ä¢ Voice coding support");
    println!("   ‚Ä¢ Multi-file understanding");
    println!("   ‚Ä¢ Learning from your coding style");
    
    println!("\\nHappy coding! üéâ");
}

// Try typing here and watch the AI suggestions appear...
// The AI will learn from your coding patterns and provide
// increasingly relevant suggestions as you work.`;

                window.editor = monaco.editor.create(document.getElementById('editor'), {
                    value: initialCode,
                    language: 'rust',
                    theme: 'vs-dark',
                    automaticLayout: true,
                    minimap: { enabled: true },
                    lineNumbers: 'on',
                    scrollBeyondLastLine: false,
                    wordWrap: 'off',
                    folding: true,
                    bracketMatching: 'always',
                    autoClosingBrackets: 'always',
                    autoClosingQuotes: 'always',
                    formatOnPaste: true,
                    formatOnType: true,
                    suggestOnTriggerCharacters: true,
                    quickSuggestions: true,
                    parameterHints: { enabled: true },
                    hover: { enabled: true },
                    links: false,
                    find: {
                        addExtraSpaceOnTop: false,
                        autoFindInSelection: 'never',
                        seedSearchStringFromSelection: 'always',
                    },
                    tabSize: 4,
                    insertSpaces: true,
                    detectIndentation: true,
                    rulers: [80],
                    renderWhitespace: 'selection',
                    renderControlCharacters: false,
                    fontSize: 14,
                    fontFamily: 'Fira Code, Monaco, Consolas, monospace',
                    lineHeight: 22,
                    letterSpacing: 0.5,
                    fontLigatures: true,
                });

                // Setup event listeners for Monaco Editor
                window.editor.onDidChangeModelContent(function() {
                    handleCodeChange();
                });

                window.editor.onKeyDown(function(e) {
                    handleKeyPress(e);
                });

                window.editor.onDidChangeCursorPosition(function() {
                    updateCursorPosition();
                });

                // Register AI completion provider
                monaco.languages.registerCompletionItemProvider('rust', {
                    provideCompletionItems: function(model, position) {
                        return requestAICompletion(model, position);
                    }
                });

                monaco.languages.registerCompletionItemProvider('python', {
                    provideCompletionItems: function(model, position) {
                        return requestAICompletion(model, position);
                    }
                });

                monaco.languages.registerCompletionItemProvider('javascript', {
                    provideCompletionItems: function(model, position) {
                        return requestAICompletion(model, position);
                    }
                });

                console.log('Monaco Editor initialized successfully');
            });
        }

        // Request AI completion from backend
        function requestAICompletion(model, position) {
            const textBeforeCursor = model.getValueInRange({
                startLineNumber: 1,
                startColumn: 1,
                endLineNumber: position.lineNumber,
                endColumn: position.column
            });

            const language = model.getLanguageId();
            
            if (ws && ws.readyState === WebSocket.OPEN && aiEnabled) {
                ws.send(JSON.stringify({
                    type: 'request_completion',
                    document_id: currentFile,
                    cursor_position: { line: position.lineNumber, column: position.column },
                    text_context: textBeforeCursor,
                    language: language
                }));
            }

            // Return empty suggestions for now, will be populated by WebSocket response
            return { suggestions: [] };
        }
        
        // Handle code changes
        let codeChangeTimeout;
        function handleCodeChange() {
            clearTimeout(codeChangeTimeout);
            codeChangeTimeout = setTimeout(() => {
                sendCodeForAnalysis();
            }, 500);
        }
        
        // Send code for AI analysis
        async function sendCodeForAnalysis() {
            if (window.editor) {
                const code = window.editor.getValue();
                
                if (ws && ws.readyState === WebSocket.OPEN && aiEnabled) {
                    ws.send(JSON.stringify({
                        type: 'code_change',
                        document_id: currentFile,
                        content: code,
                        position: getCursorPosition(),
                        language: window.editor.getModel().getLanguageId()
                    }));
                }
            }
        }
        
        // Show AI suggestion
        function showAISuggestion(suggestion, confidence) {
            const aiSuggestions = document.getElementById('ai-suggestions');
            const suggestionElement = document.createElement('div');
            suggestionElement.className = 'ai-suggestion';
            suggestionElement.innerHTML = `
                <strong>AI Suggestion (${Math.round(confidence * 100)}% confidence):</strong>
                ${suggestion}
                <br><button class="btn btn-primary" onclick="acceptSuggestion()">Accept</button>
                <button class="btn btn-secondary" onclick="rejectSuggestion()">Dismiss</button>
            `;
            aiSuggestions.appendChild(suggestionElement);
        }
        
        // Handle key presses
        function handleKeyPress(e) {
            // Ctrl+S to save
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                saveFile();
            }
            
            // Ctrl+Space for AI completion
            if (e.ctrlKey && e.key === ' ') {
                e.preventDefault();
                requestCompletion();
            }
            
            // Tab for auto-completion
            if (e.key === 'Tab') {
                e.preventDefault();
                completeLine();
            }
        }
        
        // Request auto-completion
        function requestCompletion() {
            if (window.editor) {
                const position = window.editor.getPosition();
                const model = window.editor.getModel();
                const textBefore = model.getValueInRange({
                    startLineNumber: 1,
                    startColumn: 1,
                    endLineNumber: position.lineNumber,
                    endColumn: position.column
                });
                
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'request_completion',
                        document_id: currentFile,
                        cursor_position: getCursorPosition(),
                        text_context: textBefore,
                        language: model.getLanguageId()
                    }));
                }
            }
        }
        
        // Get cursor position
        function getCursorPosition() {
            if (window.editor) {
                const position = window.editor.getPosition();
                return {
                    line: position.lineNumber,
                    column: position.column
                };
            } else {
                return { line: 1, column: 1 };
            }
        }
        
        // Update status bar
        function updateStatus() {
            const statusItems = document.querySelectorAll('.status-item');
            const position = getCursorPosition();
            
            statusItems[0].innerHTML = `<span>Line ${position.line}, Col ${position.column}</span>`;
            
            // Update file status
            const saveStatus = statusItems[2];
            saveStatus.innerHTML = '<span>üîÑ Saved just now</span>';
        }
        
        // Update AI status indicator
        function updateAIStatus(connected) {
            const aiStatus = document.getElementById('ai-status');
            if (connected && aiEnabled) {
                aiStatus.style.backgroundColor = '#4EC9B0';
                aiStatus.nextElementSibling.textContent = 'AI Connected';
            } else {
                aiStatus.style.backgroundColor = '#DC3545';
                aiStatus.nextElementSibling.textContent = 'AI Disconnected';
            }
        }
        
        // Toggle AI assistant panel
        function toggleAI() {
            const aiPanel = document.getElementById('ai-assistant');
            aiPanel.style.display = aiPanel.style.display === 'none' ? 'block' : 'none';
        }
        
        // Open file
        async function openFile(filename) {
            if (!filename) {
                // File picker would go here
                return;
            }
            
            try {
                // Send request to open file via WebSocket
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'open_file',
                        filename: filename
                    }));
                }
                
                // Fallback to HTTP API
                const response = await fetch(`/api/files/open`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ filename: filename })
                });
                
                const result = await response.json();
                
                if (result.success && result.content !== undefined) {
                    currentFile = filename;
                    
                    // Load file content into Monaco Editor
                    if (window.editor) {
                        const model = monaco.editor.createModel(result.content, getLanguageFromFilename(filename));
                        window.editor.setModel(model);
                    }
                    
                    // Update tab bar
                    updateTabBar(filename);
                    
                    // Update status
                    updateStatusBar(`Opened ${filename}`);
                    
                    // Detect language and update editor settings
                    updateEditorLanguage(filename);
                } else {
                    throw new Error(result.message || 'Failed to open file');
                }
            } catch (error) {
                console.error('Failed to open file:', error);
                updateStatusBar(`Error opening file: ${error.message}`);
            }
        }

        // Get language from filename
        function getLanguageFromFilename(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            const languageMap = {
                'rs': 'rust',
                'py': 'python',
                'js': 'javascript',
                'ts': 'typescript',
                'java': 'java',
                'cpp': 'cpp',
                'cc': 'cpp',
                'cxx': 'cpp',
                'c': 'c',
                'cs': 'csharp',
                'go': 'go',
                'php': 'php',
                'rb': 'ruby',
                'swift': 'swift',
                'kt': 'kotlin',
                'scala': 'scala',
                'sh': 'shell',
                'bash': 'shell',
                'html': 'html',
                'css': 'css',
                'json': 'json',
                'xml': 'xml',
                'yaml': 'yaml',
                'yml': 'yaml',
                'md': 'markdown',
                'txt': 'plaintext'
            };
            return languageMap[ext] || 'plaintext';
        }

        // Update editor language
        function updateEditorLanguage(filename) {
            if (window.editor) {
                const language = getLanguageFromFilename(filename);
                const model = window.editor.getModel();
                monaco.editor.setModelLanguage(model, language);
            }
        }
        
        // Save file
        async function saveFile() {
            try {
                const response = await fetch(`/api/save/${encodeURIComponent(currentFile)}`, {
                    method: 'POST'
                });
                const result = await response.json();
                
                if (result.success) {
                    updateStatusBar('File saved successfully');
                    removeTabModifiedIndicator();
                }
            } catch (error) {
                console.error('Failed to save file:', error);
            }
        }
        
        // Update tab bar
        function updateTabBar(filename) {
            const tabBar = document.getElementById('tab-bar');
            const existingTab = tabBar.querySelector(`[data-file="${filename}"]`);
            
            if (!existingTab) {
                const newTab = document.createElement('div');
                newTab.className = 'tab';
                newTab.setAttribute('data-file', filename);
                newTab.innerHTML = `
                    <span>${filename}</span>
                    <button class="close-btn" onclick="closeTab('${filename}')">√ó</button>
                `;
                
                // Add before the "Add Tab" button
                tabBar.insertBefore(newTab, tabBar.lastElementChild);
            }
            
            // Switch to this tab
            switchToTab(filename);
        }
        
        // Switch to tab
        function switchToTab(filename) {
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => tab.classList.remove('active'));
            
            const targetTab = document.querySelector(`[data-file="${filename}"]`);
            if (targetTab) {
                targetTab.classList.add('active');
                currentFile = filename;
            }
        }
        
        // Close tab
        function closeTab(filename) {
            const tab = document.querySelector(`[data-file="${filename}"]`);
            if (tab) {
                tab.remove();
                // Switch to first available tab or create new one
            }
        }
        
        // Add new tab
        function addNewTab() {
            const filename = `untitled-${Date.now()}.rs`;
            updateTabBar(filename);
        }
        
        // Remove tab modified indicator
        function removeTabModifiedIndicator() {
            const tab = document.querySelector(`[data-file="${currentFile}"]`);
            if (tab) {
                tab.classList.remove('tab-modified');
            }
        }
        
        // Update status bar temporarily
        function updateStatusBar(message) {
            const statusRight = document.querySelector('.status-right');
            const statusItem = document.createElement('div');
            statusItem.className = 'status-item';
            statusItem.innerHTML = `<span>${message}</span>`;
            statusRight.appendChild(statusItem);
            
            setTimeout(() => {
                statusItem.remove();
            }, 3000);
        }
        
        // File operations
        function refreshFiles() {
            loadFiles();
        }

        // Git operations
        async function commitChanges() {
            const message = prompt('Enter commit message:');
            if (message && message.trim()) {
                try {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({
                            type: 'git_commit',
                            message: message.trim()
                        }));
                    }
                    updateStatusBar('Committing changes...');
                } catch (error) {
                    updateStatusBar('Failed to commit: ' + error.message);
                }
            }
        }

        async function switchBranch(branchName) {
            try {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'git_checkout',
                        branch: branchName
                    }));
                }
                updateStatusBar(`Switching to branch: ${branchName}`);
            } catch (error) {
                updateStatusBar('Failed to switch branch: ' + error.message);
            }
        }

        async function createBranch() {
            const branchName = prompt('Enter new branch name:');
            if (branchName && branchName.trim()) {
                try {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({
                            type: 'git_create_branch',
                            branch: branchName.trim()
                        }));
                    }
                    updateStatusBar(`Creating branch: ${branchName}`);
                } catch (error) {
                    updateStatusBar('Failed to create branch: ' + error.message);
                }
            }
        }

        async function showCommitHistory() {
            try {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'git_commits' }));
                }
                updateStatusBar('Loading commit history...');
            } catch (error) {
                updateStatusBar('Failed to load commit history: ' + error.message);
            }
        }

        // Save file with backend integration
        async function saveFile() {
            if (!currentFile || !window.editor) {
                updateStatusBar('No file to save');
                return;
            }

            try {
                const content = window.editor.getValue();
                
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'save_file',
                        filename: currentFile,
                        content: content
                    }));
                }
                
                // Also use HTTP fallback
                const response = await fetch(`/api/files/save`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        filename: currentFile, 
                        content: content 
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    updateStatusBar(`Saved ${currentFile}`);
                    removeTabModifiedIndicator();
                } else {
                    throw new Error(result.message || 'Failed to save file');
                }
            } catch (error) {
                console.error('Failed to save file:', error);
                updateStatusBar(`Error saving file: ${error.message}`);
            }
        }
        
        function runCode() {
            // This would compile and run the code
            updateStatusBar('Running code...');
            setTimeout(() => {
                updateStatusBar('Code execution completed');
            }, 2000);
        }
        
        // AI suggestion handlers
        function acceptSuggestion() {
            // Send feedback to AI
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'save_feedback',
                    suggestion_id: 'suggestion-' + Date.now(),
                    rating: 5,
                    accepted: true,
                    context: 'user_accepted'
                }));
            }
            
            // Remove the suggestion element
            event.target.closest('.ai-suggestion').remove();
        }
        
        function rejectSuggestion() {
            // Send feedback to AI
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'save_feedback',
                    suggestion_id: 'suggestion-' + Date.now(),
                    rating: 1,
                    accepted: false,
                    context: 'user_rejected'
                }));
            }
            
            // Remove the suggestion element
            event.target.closest('.ai-suggestion').remove();
        }
        
        // Update cursor position in status bar
        function updateCursorPosition() {
            updateStatus();
        }
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', initIDE);
        
        // Periodic updates
        setInterval(() => {
            updateStatus();
        }, 1000);
        
        // Handle window resize
        window.addEventListener('resize', function() {
            // Adjust layout if needed
        });
    </script>
</body>
</html>